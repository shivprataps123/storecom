{"ast":null,"code":"import _objectSpread from \"D:/Mystore/MyStore/storecom/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"D:/Mystore/MyStore/storecom/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"root\"];\n\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nvar observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\n\nvar observers = new WeakMap();\n\nvar fireObserverCallback = function fireObserverCallback(entry) {\n  var callback = observerCallbacks.get(entry.target);\n  callback && callback(entry);\n};\n\nvar fireAllObserverCallbacks = function fireAllObserverCallbacks(entries) {\n  entries.forEach(fireObserverCallback);\n};\n\nfunction initIntersectionObserver(_ref) {\n  var root = _ref.root,\n      options = _objectWithoutProperties(_ref, _excluded);\n\n  var lookupRoot = root || document;\n  /**\n   * If we don't have an observer lookup map for this root, create one.\n   */\n\n  if (!observers.has(lookupRoot)) {\n    observers.set(lookupRoot, {});\n  }\n\n  var rootObservers = observers.get(lookupRoot);\n  var key = JSON.stringify(options);\n  /**\n   * If we don't have an observer for this combination of root and settings,\n   * create one.\n   */\n\n  if (!rootObservers[key]) {\n    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, _objectSpread({\n      root: root\n    }, options));\n  }\n\n  return rootObservers[key];\n}\n\nfunction observeIntersection(element, options, callback) {\n  var rootInteresectionObserver = initIntersectionObserver(options);\n  observerCallbacks.set(element, callback);\n  rootInteresectionObserver.observe(element);\n  return function () {\n    observerCallbacks.delete(element);\n    rootInteresectionObserver.unobserve(element);\n  };\n}\n\nexport { observeIntersection };","map":{"version":3,"names":["observerCallbacks","WeakMap","observers","fireObserverCallback","entry","callback","get","target","fireAllObserverCallbacks","entries","forEach","initIntersectionObserver","root","options","lookupRoot","document","has","set","rootObservers","key","JSON","stringify","IntersectionObserver","observeIntersection","element","rootInteresectionObserver","observe","delete","unobserve"],"sources":["D:/Mystore/MyStore/storecom/node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs"],"sourcesContent":["/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = (entry) => {\n    const callback = observerCallbacks.get(entry.target);\n    callback && callback(entry);\n};\nconst fireAllObserverCallbacks = (entries) => {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({ root, ...options }) {\n    const lookupRoot = root || document;\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    const rootObservers = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return () => {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\nexport { observeIntersection };\n"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA,IAAMA,iBAAiB,GAAG,IAAIC,OAAJ,EAA1B;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,SAAS,GAAG,IAAID,OAAJ,EAAlB;;AACA,IAAME,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,KAAD,EAAW;EACpC,IAAMC,QAAQ,GAAGL,iBAAiB,CAACM,GAAlB,CAAsBF,KAAK,CAACG,MAA5B,CAAjB;EACAF,QAAQ,IAAIA,QAAQ,CAACD,KAAD,CAApB;AACH,CAHD;;AAIA,IAAMI,wBAAwB,GAAG,SAA3BA,wBAA2B,CAACC,OAAD,EAAa;EAC1CA,OAAO,CAACC,OAAR,CAAgBP,oBAAhB;AACH,CAFD;;AAGA,SAASQ,wBAAT,OAAwD;EAAA,IAApBC,IAAoB,QAApBA,IAAoB;EAAA,IAAXC,OAAW;;EACpD,IAAMC,UAAU,GAAGF,IAAI,IAAIG,QAA3B;EACA;AACJ;AACA;;EACI,IAAI,CAACb,SAAS,CAACc,GAAV,CAAcF,UAAd,CAAL,EAAgC;IAC5BZ,SAAS,CAACe,GAAV,CAAcH,UAAd,EAA0B,EAA1B;EACH;;EACD,IAAMI,aAAa,GAAGhB,SAAS,CAACI,GAAV,CAAcQ,UAAd,CAAtB;EACA,IAAMK,GAAG,GAAGC,IAAI,CAACC,SAAL,CAAeR,OAAf,CAAZ;EACA;AACJ;AACA;AACA;;EACI,IAAI,CAACK,aAAa,CAACC,GAAD,CAAlB,EAAyB;IACrBD,aAAa,CAACC,GAAD,CAAb,GAAqB,IAAIG,oBAAJ,CAAyBd,wBAAzB;MAAqDI,IAAI,EAAJA;IAArD,GAA8DC,OAA9D,EAArB;EACH;;EACD,OAAOK,aAAa,CAACC,GAAD,CAApB;AACH;;AACD,SAASI,mBAAT,CAA6BC,OAA7B,EAAsCX,OAAtC,EAA+CR,QAA/C,EAAyD;EACrD,IAAMoB,yBAAyB,GAAGd,wBAAwB,CAACE,OAAD,CAA1D;EACAb,iBAAiB,CAACiB,GAAlB,CAAsBO,OAAtB,EAA+BnB,QAA/B;EACAoB,yBAAyB,CAACC,OAA1B,CAAkCF,OAAlC;EACA,OAAO,YAAM;IACTxB,iBAAiB,CAAC2B,MAAlB,CAAyBH,OAAzB;IACAC,yBAAyB,CAACG,SAA1B,CAAoCJ,OAApC;EACH,CAHD;AAIH;;AAED,SAASD,mBAAT"},"metadata":{},"sourceType":"module"}